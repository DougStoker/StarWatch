<html>

<head>
    <title>Night Watch</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-touch-fullscreen" content="yes" />
    <style>
        html, body {margin: 0; padding: 0; width:100%; height:100%; overflow: hidden; position: fixed; }
        canvas {
            border: 1px solid rgb(199, 241, 237);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 95vw;
            height: 95vh;
        }

        #starsVideo {
            position: fixed;
            right: 0;
            bottom: 0;
            min-width: 100%;
            min-height: 100%;
            z-index: -100;
        }

    </style>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js'></script>

</head>

<body onload="startGame()">

    <video autoplay muted loop id="starsVideo">
        <source src="stars.mp4" type="video/mp4">
    </video>

    <header style="text-align: center; font-size: bolder; color: rgb(199, 241, 237)">Night Watch</header>

    <script>
        //var myGamePiece;
        let myUUID = uuidv4();
        var gamePieces = {};
        let myColor = getRandomColor();
        var itUUID;
        let imit = false;
        let pieceWidth = 30;
        let pieceHeight = 30;
        let itfilla = '#aa0000';
        let itfillb = '#99ff00';
        var itfill = itfilla;
        const GAME_FRICTION = 0.975
        const PLAYER_MASS = 10

        const wrapMod = (x, n) => (x % n + n) % n

        class vec2{
            constructor(x,y){
                this.x = x
                this.y = y
            }
            add_vec_to =(other)=>{
                return new vec2(this.x + other.x,
                this.y + other.y)
            }
            add_vec_to =(other)=>{
                this.x += other.x
                this.y += other.y
            }
            divide_num =(number)=>{
                this.y /= number
                this.x /= number
            }
            times_num =(num)=>{
                this.y *= num
                this.x *= num
            }

            wrap_mod_xy =(x,y)=>{
                this.y = wrapMod(this.y,y)
                this.x = wrapMod(this.x,x)
            }

            mod_xy =(x,y)=>{
                this.y %= y
                this.x %= x
            }
            abs =()=>{
                if(this.x < 0){this.x = -this.x}
                if(this.y < 0){this.y = -this.y}
            }
            magnitude  =()=>{
                return math.pow(this.x*this.x+this.y*this.y,0.5)
            }
        }
        var cango = true;

        var socket = io('//:3000') // for localhost testing
     //var socket = io('https://nightwatch-server.now.sh')
        socket.on('announce', () => {
            //console.log("announce received")
            var myGamePiece = gamePieces[myUUID];
            socket.emit('move', {
                uuid: myUUID,
                x: myGamePiece.pos.x,
                y: myGamePiece.pos.y,
                color: myColor
            });
        })
        socket.on('it', (data) => {
            //console.log('Got it data: ', data)
            itUUID = data.uuid;
            if (itUUID == myUUID) { // I'm it!
                imit = true;
            } else {
                imit = false;
            }
            let flashIt = setInterval( function() { changeItColor() }, 100);
            setTimeout(function() { clearInterval(flashIt); itfill = itfilla; }, 3000);
        })

        socket.on('moved', function (data) {
            //console.log("move received:");
            //console.log(data);
            // This is where we parse the data object for the new box to draw
            if (typeof gamePieces[data.uuid] != "undefined") {
                gamePieces[data.uuid].x = data.x;
                gamePieces[data.uuid].y = data.y;
            } else {
                gamePieces[data.uuid] = new component(pieceWidth, pieceHeight, data.color, data.x, data.y);
            }
            // socket.emit('moved')
        });
        socket.on('remove', function (data) {
            // We should make some pretty animation here
            if (typeof gamePieces[data.uuid] != 'undefined') {
                delete gamePieces[data.uuid];
            }
        })



        var myGameArea = {
            canvas: document.createElement("canvas"),
            start: function () {
                this.canvas.width = 1280;
                this.canvas.height = 720;
                this.context = this.canvas.getContext("2d");
                document.body.insertBefore(this.canvas, document.body.childNodes[0]);
                //document.body.style.backgroundImage = "url('https://d2v9y0dukr6mq2.cloudfront.net/video/thumbnail/Hme4C4_7iosf3emf/stars-in-the-sky-looped-animation-beautiful-night-with-twinkling-flares-hd-1080_sr8wih9v__F0000.png')";
                this.interval = setInterval(updateGameArea, getRandomInt(5, 1));
                this.interval2 = setInterval(updateRefresh, getRandomInt(50, 10));
                window.addEventListener('keydown', function (e) {
                    e.preventDefault();
                    myGameArea.keys = (myGameArea.keys || []);
                    myGameArea.keys[e.keyCode] = true;
                    
                })
                window.addEventListener('keyup', function (e) {
                    e.preventDefault();
                    myGameArea.keys = (myGameArea.keys || []);
                    myGameArea.keys[e.keyCode] = false;
                })

                window.addEventListener('mousedown', function (e) {
                    e.preventDefault();
                    myGameArea.mouse = true;
                    myGameArea.mouseY = e.movementY;
                    myGameArea.mouseX = e.movementX;
                })

                window.addEventListener('mousemove', function (e) {
                    e.preventDefault();
                    // This prevents us from sending a "stopping" event, 0,0
                    // To make it allow for more angular movements, 
                    // it would be good to keep the last three events and send
                    // the average down to the gameArea
                    if (e.movementY != 0 || e.movementX != 0 ) {
                        myGameArea.mouseY = e.movementY;
                        myGameArea.mouseX = e.movementX;
                    }
                })

                window.addEventListener('mouseup', function(e) {
                    myGameArea.mouse = false;
                })

                window.addEventListener('mouseout', function(e) {
                    myGameArea.mouse = false;
                })
                window.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    myGameArea.touch = true;
                    myGameArea.touches = e.touches;
                    myGameArea.changedTouches = [];
                })
                window.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                    myGameArea.touches = e.touches;
                    myGameArea.changedTouches = e.changedTouches;
                })
                window.addEventListener('touchend', function(e) {
                    myGameArea.touch = false;
                    myGameArea.touches = [];
                    myGameArea.changedTouches = [];
                })
            },
            clear: function () {
                //this.canvas.height = this.canvas.clientHeight * 0.95;
                //this.canvas.width = this.canvas.clientWidth * 0.95;
                let width = this.canvas.width;
                let height = this.canvas.height;
                //console.log("w: " + width + " h: " + height);
                this.context.clearRect(0, 0, width, height);
            }
        }

        function updateRefresh() {
            clearInterval(myGameArea.interval);
            clearInterval(myGameArea.interval2);
            myGameArea.interval = setInterval(updateGameArea, getRandomInt(5, 1));
            myGameArea.interval2 = setInterval(updateRefresh, getRandomInt(50, 10));
        }

        function startGame() {
            myGameArea.start();
            gamePieces[myUUID] = new component(pieceWidth, pieceHeight, myColor, 595, 20);
            socket.emit('move', {
                uuid: myUUID,
                x: gamePieces[myUUID].pos.x,
                y: gamePieces[myUUID].pos.y,
                color: myColor
            });
        }

        function component(width, height, color, x, y) {
            this.width = width;
            this.height = height;
            this.radius = width/2; // for circles
            this.mass  = PLAYER_MASS
            //this.vel.x = 0;
            //this.vel.y = 0;
            //this.x = x;
            //this.y = y;
            this.vel = new vec2(0,0)
            this.pos = new vec2(x,y)
            this.shipImage = new Image();
            this.shipImage.src = 'ship.jpg';
            this.update = function (it,itcolor) {
                ctx = myGameArea.context;

                // A square
                //ctx.fillRect(this.x, this.y, this.width, this.height);

                // A circle
                let radius = this.radius;
                ctx.beginPath();
                ctx.arc(this.pos.x,this.pos.y,radius,0,2*Math.PI)
                ctx.fillStyle = color;
                ctx.fill();

                // A ship
                //ctx.drawImage(this.shipImage, 0, 0, this.shipImage.width, this.shipImage.height,this.x, this.y, this.width, this.height);

                if (it) {

                    // This gives us a square
                    
                    ctx.fillStyle = itcolor;
                    let ptf = 5;
                    
                    // A circle in the middle
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, ptf, 0, 2*Math.PI)
                    ctx.fill();
                    // A square in the middle
                    //ctx.fillRect(this.x + (pieceWidth / ptf), this.y + (pieceHeight / ptf), this.width - ((
                    //    pieceWidth / ptf) * 2), this.height - ((pieceWidth / ptf) * 2));

                        
                    /* This creates a hole in the ship */
                    /*
                    ctx.globalCompositeOperation = 'destination-out'
                    ctx.arc(this.x + width/2, this.y + height/2, 10, 0, 2*Math.PI)
                    ctx.fill()
                    */

                }
            }
/*             this.newPos = function () {
                if (this.x + this.vel.x + pieceWidth < 0 ) {
                    this.x += myGameArea.canvas.width + pieceWidth;
                } else if (this.x + this.vel.x > myGameArea.canvas.width) {
                    this.x -= myGameArea.canvas.width + pieceWidth;
                } else {
                    this.x += this.vel.x;
                }
                if (this.posy + this.vel.y + pieceHeight < 0) {
                    this.y += myGameArea.canvas.height + pieceHeight;
                } else if (this.pos.y + this.vel.y > myGameArea.canvas.height) {
                    this.y -= myGameArea.canvas.height  + pieceHeight;
                } else {
                    this.y += this.vel.y;
                }

            } */
            this.updatePos = function(){
                this.pos.add_vec_to(this.vel)
                this.pos.wrap_mod_xy(myGameArea.canvas.width,myGameArea.canvas.height)
             
                this.brake(GAME_FRICTION)
            }
            this.acel =  function(force){
                //console.log(force)
                force.divide_num(this.mass)
                this.vel.add_vec_to(force)
            }
            this.brake = function(num){
                this.vel.times_num(num)
            }
        }

        function updateGameArea() {
            myGameArea.clear();
            var myGamePiece = gamePieces[myUUID];
            
            if (myGameArea.mouse) {

                let mouseX = myGameArea.mouseX
                let mouseY = myGameArea.mouseY
                //console.log("X "+mouseX + " Y " + mouseY)

                    if (mouseX > 0) {
                        //myGamePiece.vel.x = 1;
                        myGamePiece.acel(new vec2(1,0))

                    } else if (mouseX < 0) {
                        myGamePiece.vel.x = -1;
                        myGamePiece.acel(new vec2(-1,0))
                    } //else { myGamePiece.vel.x = 0 }
                
                    if (mouseY > 0) {
                        //myGamePiece.vel.y = 1;
                        myGamePiece.acel(new vec2(0,1))
                    } else if (mouseY < 0 ) {
                        //myGamePiece.vel.y = -1;
                        myGamePiece.acel(new vec2(0,-1))
                    } //else { myGamePiece.vel.y = 0 }

                // end mouse movement checks
            } else if (myGameArea.touch) {
                let changedTouches = myGameArea.changedTouches
                let oldTouchSpot = (myGameArea.oldTouchSpot || changedTouches[0]);
                let touch = changedTouches[0]
                let diffX = touch.pageX - oldTouchSpot.pageX
                let diffY = touch.pageY - oldTouchSpot.pageY
                myGameArea.oldTouchSpot = changedTouches[0]

                if (diffX != 0 || diffY != 0) {
                    if (diffX > 0) {
                        //myGamePiece.vel.x = 1; 
                        myGamePiece.acel(new vec2(1,0))
                    } else if (diffX < 0) {
                        //myGamePiece.vel.x = -1;
                        myGamePiece.acel(new vec2(-1,0))
                    }  //else { myGamePiece.vel.x = 0}

                    if (diffY > 0 ){
                       //myGamePiece.vel.y = 1;
                       myGamePiece.acel(new vec2(0,1))
                    } else if (diffY < 0) {
                        //myGamePiece.vel.y = -1;
                        myGamePiece.acel(new vec2(0,-1))
                    } //else { myGamePiece.vel.y = 0 }
                }

            } else {
                //myGamePiece.vel.x = 0;
                //myGamePiece.vel.y = 0;

            if (myGameArea.keys && myGameArea.keys[37]) {
                //myGamePiece.vel.x = -1;
                myGamePiece.acel(new vec2(-1,0))
            }
            if (myGameArea.keys && myGameArea.keys[39]) {
                //myGamePiece.vel.x = 1;
                myGamePiece.acel(new vec2(1,0))
            }
            if (myGameArea.keys && myGameArea.keys[38]) {
                //myGamePiece.vel.y = -1;
                myGamePiece.acel(new vec2(0,-1))
            }
            if (myGameArea.keys && myGameArea.keys[40]) {
                //myGamePiece.vel.y = 1;
                myGamePiece.acel(new vec2(0,1))
            }
            // end keypress checks
            }

            if (cango && (myGamePiece.vel.x != 0 || myGamePiece.vel.y != 0)) {
                socket.emit('move', {
                    uuid: myUUID,
                    x: myGamePiece.pos.x,
                    y: myGamePiece.pos.y,
                    color: myColor
                });
                //console.log(myGamePiece);
            } else if (!cango && myGamePiece.vel.x == 0 && myGamePiece.vel.y == 0) { 
                cango = true;
            } else if (!cango) {
                //myGamePiece.vel.x = 0;
                //myGamePiece.vel.y = 0;
            }
            myGamePiece.updatePos()

            for (var uuid in gamePieces) {
                if (uuid != myUUID) {
                    if (checkOverlap(myGamePiece, gamePieces[uuid])) {
                        //console.log('overlap! ' + myUUID + " - " + uuid);
                        if (imit) {
                        socket.emit('tagged', {
                            olduuid: myUUID,
                            newuuid: uuid
                         })
                        } 
                        cango = true;
                    }
                }
                gamePieces[uuid].update(uuid == itUUID,itfill);
            }
        }

        function changeItColor() {
            if (itfill === itfilla) {
                itfill = itfillb;
            } else {
                itfill = itfilla;
            }
        }

        function checkOverlap(piece1, piece2) {

            // This is for square collision detection

            //console.log("checking for overlap")
            /*
            if (piece1.x > piece2.x + pieceWidth || piece2.x > piece1.x + pieceWidth) {
                //console.log("no overlap side-to-side");
                return false;
            }
            if (piece1.y > piece2.y + pieceHeight || piece2.y > piece1.y + pieceHeight) {
                //console.log("no overlap top-to-bottom")
                return false;
            }
            return true;
            */
            // This is for circle collision detection

            //let vsum = piece1.vel.add_vec_to(pi)

            let dx = piece1.pos.x - piece2.pos.x;
            let dy = piece1.pos.y - piece2.pos.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < piece1.radius + piece2.radius)  {
                return true
            } else { 
                return false
            }
        }


        function uuidv4() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0,
                    v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function getRandomColor() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function getRandomInt(max, min) {
            if (min == null || min == undefined) {
                min = 0
            }
            return Math.floor(Math.random() * Math.floor(max - min) + min)
        }
    </script>

</body>

</html>
