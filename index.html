<html>

<head>
    <title>Night Watch</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        canvas {
            border: 1px solid rgb(199, 241, 237);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 95vw;
            height: 95vh;
        }

        #starsVideo {
            position: fixed;
            right: 0;
            bottom: 0;
            min-width: 100%;
            min-height: 100%;
            z-index: -100;
        }

    </style>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js'></script>

</head>

<body onload="startGame()">

    <video autoplay muted loop id="starsVideo">
        <source src="stars.mp4" type="video/mp4">
    </video>

    <header style="text-align: center; font-size: bolder; color: rgb(199, 241, 237)">Night Watch</header>

    <script>
        //var myGamePiece;
        let myUUID = uuidv4();
        var gamePieces = {};
        let myColor = getRandomColor();
        var itUUID;
        let imit = false;
        let pieceWidth = 30;
        let pieceHeight = 30;
        let itfilla = '#aa0000';
        let itfillb = '#99ff00';
        var itfill = itfilla;

        //var socket = io('//:3000') // for localhost testing
        var socket = io('https://nightwatch-server.now.sh')
        socket.on('announce', () => {
            //console.log("announce received")
            var myGamePiece = gamePieces[myUUID];
            socket.emit('move', {
                uuid: myUUID,
                x: myGamePiece.x,
                y: myGamePiece.y,
                color: myColor
            });
        })
        socket.on('it', (data) => {
            //console.log('Got it data: ', data)
            itUUID = data.uuid;
            if (itUUID == myUUID) { // I'm it!
                imit = true;
            } else {
                imit = false;
            }
            let flashIt = setInterval( function() { changeItColor() }, 100);
            setTimeout(function() { clearInterval(flashIt); itfill = itfilla; }, 3000);
        })

        socket.on('moved', function (data) {
            //console.log("move received:");
            //console.log(data);
            // This is where we parse the data object for the new box to draw
            if (typeof gamePieces[data.uuid] != "undefined") {
                gamePieces[data.uuid].x = data.x;
                gamePieces[data.uuid].y = data.y;
            } else {
                gamePieces[data.uuid] = new component(pieceWidth, pieceHeight, data.color, data.x, data.y);
            }
            // socket.emit('moved')
        });
        socket.on('remove', function (data) {
            // We should make some pretty animation here
            if (typeof gamePieces[data.uuid] != 'undefined') {
                delete gamePieces[data.uuid];
            }
        })



        var myGameArea = {
            canvas: document.createElement("canvas"),
            start: function () {
                this.canvas.width = 1280;
                this.canvas.height = 720;
                this.context = this.canvas.getContext("2d");
                document.body.insertBefore(this.canvas, document.body.childNodes[0]);
                //document.body.style.backgroundImage = "url('https://d2v9y0dukr6mq2.cloudfront.net/video/thumbnail/Hme4C4_7iosf3emf/stars-in-the-sky-looped-animation-beautiful-night-with-twinkling-flares-hd-1080_sr8wih9v__F0000.png')";
                this.interval = setInterval(updateGameArea, getRandomInt(25, 5));
                this.interval2 = setInterval(updateRefresh, getRandomInt(5000, 1000));
                window.addEventListener('keydown', function (e) {
                    myGameArea.keys = (myGameArea.keys || []);
                    myGameArea.keys[e.keyCode] = true;
                    e.preventDefault();
                })
                window.addEventListener('keyup', function (e) {
                    myGameArea.keys[e.keyCode] = false;
                })
            },
            clear: function () {
                //this.canvas.height = this.canvas.clientHeight * 0.95;
                //this.canvas.width = this.canvas.clientWidth * 0.95;
                let width = this.canvas.width;
                let height = this.canvas.height;
                //console.log("w: " + width + " h: " + height);
                this.context.clearRect(0, 0, width, height);
            }
        }

        function updateRefresh() {
            clearInterval(myGameArea.interval);
            clearInterval(myGameArea.interval2);
            myGameArea.interval = setInterval(updateGameArea, getRandomInt(25, 5));
            myGameArea.interval2 = setInterval(updateRefresh, getRandomInt(5000, 1000));
        }

        function startGame() {
            myGameArea.start();
            gamePieces[myUUID] = new component(pieceWidth, pieceHeight, myColor, 595, 20);
            socket.emit('move', {
                uuid: myUUID,
                x: gamePieces[myUUID].x,
                y: gamePieces[myUUID].y,
                color: myColor
            });
        }

        function component(width, height, color, x, y) {
            this.width = width;
            this.height = height;
            this.speedX = 0;
            this.speedY = 0;
            this.x = x;
            this.y = y;
            this.update = function (it,itcolor) {
                ctx = myGameArea.context;
                ctx.fillStyle = color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                if (it) {
                    ctx.fillStyle = itcolor;
                    let ptf = 5;
                    ctx.fillRect(this.x + (pieceWidth / ptf), this.y + (pieceHeight / ptf), this.width - ((
                        pieceWidth / ptf) * 2), this.height - ((pieceWidth / ptf) * 2));
                }
            }
            this.newPos = function () {
                if (this.x + this.speedX + pieceWidth < 0 ) {
                    this.x += myGameArea.canvas.width + pieceWidth;
                } else if (this.x + this.speedX > myGameArea.canvas.width) {
                    this.x -= myGameArea.canvas.width + pieceWidth;
                } else {
                    this.x += this.speedX;
                }
                if (this.y + this.speedY + pieceHeight < 0) {
                    this.y += myGameArea.canvas.height + pieceHeight;
                } else if (this.y + this.speedY > myGameArea.canvas.height) {
                    this.y -= myGameArea.canvas.height  + pieceHeight;
                } else {
                    this.y += this.speedY;
                }

            }
        }

        function updateGameArea() {
            myGameArea.clear();
            var myGamePiece = gamePieces[myUUID];
            myGamePiece.speedX = 0;
            myGamePiece.speedY = 0;
            if (myGameArea.keys && myGameArea.keys[37]) {
                myGamePiece.speedX = -1;
            }
            if (myGameArea.keys && myGameArea.keys[39]) {
                myGamePiece.speedX = 1;
            }
            if (myGameArea.keys && myGameArea.keys[38]) {
                myGamePiece.speedY = -1;
            }
            if (myGameArea.keys && myGameArea.keys[40]) {
                myGamePiece.speedY = 1;
            }

            if (myGamePiece.speedX != 0 || myGamePiece.speedY != 0) {
                socket.emit('move', {
                    uuid: myUUID,
                    x: myGamePiece.x,
                    y: myGamePiece.y,
                    color: myColor
                });
                //console.log(myGamePiece);
            }

            myGamePiece.newPos()

            for (var uuid in gamePieces) {
                if (uuid != myUUID) {
                    if (imit && checkOverlap(myGamePiece, gamePieces[uuid])) {
                        //console.log('overlap! ' + myUUID + " - " + uuid);
                        socket.emit('tagged', {
                            olduuid: myUUID,
                            newuuid: uuid
                         })
                    }
                }
                gamePieces[uuid].update(uuid == itUUID,itfill);
            }
        }

        function changeItColor() {
            if (itfill === itfilla) {
                itfill = itfillb;
            } else {
                itfill = itfilla;
            }
        }

        function checkOverlap(piece1, piece2) {
            //console.log("checking for overlap")
            if (piece1.x > piece2.x + pieceWidth || piece2.x > piece1.x + pieceWidth) {
                //console.log("no overlap side-to-side");
                return false;
            }
            if (piece1.y > piece2.y + pieceHeight || piece2.y > piece1.y + pieceHeight) {
                //console.log("no overlap top-to-bottom")
                return false;
            }
            return true;
        }


        function uuidv4() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0,
                    v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function getRandomColor() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function getRandomInt(max, min) {
            if (min == null || min == undefined) {
                min = 0
            }
            return Math.floor(Math.random() * Math.floor(max - min) + min)
        }
    </script>

</body>

</html>